#pragma once

#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>

#include <detours.h>

#include "Utils.h"

/*
 * ================== PROCESS AND THREAD CREATION HOOKS
 */

/*
* CreateProcess()
* Invece di chiamare la CreateProcess() originale, chiamo DetourCreateProcessWithDllEx
* in modo che la mia Dll sia iniettata nel nuovo processo
*/
BOOL WINAPI Mine_CreateProcess(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
) {
    if (!isThreadInfected) {
        return True_CreateProcess( lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
    }

    // Se il chiamante infetto vuole chiamare CreateProcess, creo il processo richiesto in stato 'SOSPESO'
    // Scrivo il pid del processo appena creato tra quelli infetti e lo faccio partie in modo che
    // quando esegue il codice, vede che e' presente nella lista degli infetti ed eseguira' le mie funzioni di hook
    //printf("%d %d CreateProcess called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    BOOL result = True_DetourCreateProcessWithDllEx( 
        lpApplicationName,
        lpCommandLine,
        lpProcessAttributes,
        lpThreadAttributes,
        bInheritHandles,
        dwCreationFlags|CREATE_SUSPENDED,
        lpEnvironment,
        lpCurrentDirectory,
        lpStartupInfo,
        lpProcessInformation,
        Mine_Dll,
        True_CreateProcess
    );

    char infectedInfo[256];
    sprintf_s(infectedInfo, sizeof(infectedInfo), "%d -1", lpProcessInformation->dwProcessId);
    AppendLineToFile(infectedFile, infectedInfo);

    ResumeThread(lpProcessInformation->hThread);
    return result;
}

/*
* CreateRemoteThread() Hooks
* Devo iniettare questa DLL nel processo su cui e' stato creato il thread remoto e
* aggiungere pid e threadid tra quelli infetti
*/
HANDLE WINAPI Mine_CreateRemoteThread(
  HANDLE                 hProcess,
  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
  SIZE_T                 dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID                 lpParameter,
  DWORD                  dwCreationFlags,
  LPDWORD                lpThreadId
) {
    if (!isThreadInfected) {
        return True_CreateRemoteThread(hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
    }

    //printf("%d %d CreateRemoteThread called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    // Problema! Se il malware chiama LoadLibrary e essa stessa fa hook sulle funzioni del programma originale
    // non posso piu' distinguere i thread buoni da quelli malevoli
    // Se carica una libreria e poi fa partire thread che eseguono funzioni della libreria, li riesco a seguire
    // Potrei leggere i simboli della dll in qualche modo e vedere se ci sono funzioni di hooking?
    loadLibraryOnRemoteProcess(GetProcessId(hProcess), Mine_Dll);
    HANDLE hThread = True_CreateRemoteThread(hProcess,
        lpThreadAttributes,
        dwStackSize,
        lpStartAddress,
        lpParameter,
        dwCreationFlags|CREATE_SUSPENDED,
        lpThreadId
    );

    char infectedInfo[256];
    sprintf_s(infectedInfo, sizeof(infectedInfo), "%d %d", GetProcessId(hProcess), GetThreadId(hThread));
    AppendLineToFile(infectedFile, infectedInfo);

    ResumeThread(hThread);
    return hThread;
}

/*
* CreateThread() Hooks
* Il thread viene creato nel processo corrente quindi devo solo aggiungere il threadID tra quelli infetti
*/
HANDLE WINAPI Mine_CreateThread(
    LPSECURITY_ATTRIBUTES   lpThreadAttributes,
    SIZE_T                  dwStackSize,
    LPTHREAD_START_ROUTINE  lpStartAddress,
    __drv_aliasesMem LPVOID lpParameter,
    DWORD                   dwCreationFlags,
    LPDWORD                 lpThreadId
) {
    if (!isThreadInfected) {
        return True_CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
    }

    HANDLE hThread = True_CreateThread(
        lpThreadAttributes,
        dwStackSize,
        lpStartAddress,
        lpParameter,
        dwCreationFlags | CREATE_SUSPENDED,
        lpThreadId 
    );
    //printf("%d %d CreateThread called! Created ThreadID: %d\n", GetCurrentProcessId(), GetCurrentThreadId(), GetThreadId(hThread));

    char infectedInfo[256];
    sprintf_s(infectedInfo, sizeof(infectedInfo), "%d %d", GetCurrentProcessId(), GetThreadId(hThread));
    AppendLineToFile(infectedFile, infectedInfo);

    ResumeThread(hThread);
    return hThread;
}

NTSTATUS NTAPI Mine_NtCreateThreadEx(
    OUT PHANDLE hThread,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes,
    IN HANDLE ProcessHandle,
    IN PVOID lpStartAddress,
    IN PVOID lpParameter,
    IN ULONG Flags,
    IN SIZE_T StackZeroBits,
    IN SIZE_T SizeOfStackCommit,
    IN SIZE_T SizeOfStackReserve,
    OUT PVOID lpBytesBuffer
) {
    printf("%d %d NtCreateThreadEx Undocumented called!\n", GetCurrentProcessId(), GetCurrentThreadId());

    NTSTATUS res = True_NtCreateThreadEx(hThread, DesiredAccess, ObjectAttributes, ProcessHandle, lpStartAddress, lpParameter, Flags, StackZeroBits, SizeOfStackCommit, SizeOfStackReserve, lpBytesBuffer );
    return res;
}

/*
 * ==================== NETWORK RELATED HOOKS
 */
/*
* WSASend() hooks
* Devo vedere se ogni chiamata dia WSASend mappa gli indirizzi IPv4 in IPv6, perche' poi nella cattura di wireshark compare l'IPv4
*/
int WSAAPI Mine_WSASend(
    SOCKET                             s,
    LPWSABUF                           lpBuffers,
    DWORD                              dwBufferCount,
    LPDWORD                            lpNumberOfBytesSent,
    DWORD                              dwFlags,
    LPWSAOVERLAPPED                    lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
) {
    if (!isThreadInfected) {
        return True_WSASend( s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine );
    }

    //printf("%d %d WSASend called!\n", GetCurrentProcessId(), GetCurrentThreadId());

    SocketInfo tcpInfo;
    GetSocketInfo(s, &tcpInfo);

    if (strncmp(tcpInfo.localHostName, "::ffff:", 7) == 0) {
        memmove(tcpInfo.localHostName, tcpInfo.localHostName + 7, strlen(tcpInfo.localHostName) - 6);  // Remove the '::ffff:' prefix
    }
    if (strncmp(tcpInfo.remoteHostName, "::ffff:", 7) == 0) {
        memmove(tcpInfo.remoteHostName, tcpInfo.remoteHostName + 7, strlen(tcpInfo.remoteHostName) - 6);  // Remove the '::ffff:' prefix
    }

    char timestamp[32];
    getUniversalTimeStr(timestamp, sizeof(timestamp));

    char line[512];
    sprintf_s(line, sizeof(line), "%s,%s,%s,%d,%s,%s,%d,%d", timestamp, tcpInfo.localHostName, tcpInfo.remoteHostName, tcpInfo.Protocol, tcpInfo.localSrvPort, tcpInfo.remoteSrvPort, tcpInfo.AddressFamily, tcpInfo.SocketType);
    printf("WSASend:\t%s,%s,%s,%d,%s,%s,%d,%d\n", timestamp, tcpInfo.localHostName, tcpInfo.remoteHostName, tcpInfo.Protocol, tcpInfo.localSrvPort, tcpInfo.remoteSrvPort, tcpInfo.AddressFamily, tcpInfo.SocketType);
    logLine(line);

    int res = True_WSASend( s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine );
    return res;
}

/*
 * WSARecv() https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsarecv
 * Problema: 
 *      Alcune volte quando invio una richiesta HTTP con WSASend(), oltre a ricevere il normale pacchetto di risposta con WSARecv
 *      il mio programma chiama di nuovo WSARecv(), ma senza che questo pacchetto appaia in wireshark
 * Provo ad aggiungere un controllo che salva le informazioni sono se il pacchetto e' stato ricevuto correttamente
 * Possibili cause:
 * 1. Delayed ACK: TCP/IP has a feature called "Delayed ACK," where the system may delay sending an acknowledgment for received data, 
 *      combining multiple ACKs into a single packet to reduce overhead. This behavior can lead to a delay in the acknowledgment packets.
 * 2. Buffering and Flow Control: It's possible that the data sent and received by your application gets buffered in network stack layers
 *      or by the underlying network driver before it's transmitted or processed.
 */
int WSAAPI Mine_WSARecv(
    SOCKET                             s,
    LPWSABUF                           lpBuffers,
    DWORD                              dwBufferCount,
    LPDWORD                            lpNumberOfBytesRecvd,
    LPDWORD                            lpFlags,
    LPWSAOVERLAPPED                    lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
) {
    if (!isThreadInfected) {
        return True_WSARecv( s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine );
    }

    //printf("%d %d WSARecv called!\n", GetCurrentProcessId(), GetCurrentThreadId());

    SocketInfo tcpInfo;
    GetSocketInfo(s, &tcpInfo);

    if (strncmp(tcpInfo.localHostName, "::ffff:", 7) == 0) {
        memmove(tcpInfo.localHostName, tcpInfo.localHostName + 7, strlen(tcpInfo.localHostName) - 6);  // Remove the '::ffff:' prefix
    }
    if (strncmp(tcpInfo.remoteHostName, "::ffff:", 7) == 0) {
        memmove(tcpInfo.remoteHostName, tcpInfo.remoteHostName + 7, strlen(tcpInfo.remoteHostName) - 6);  // Remove the '::ffff:' prefix
    }

    char timestamp[32];
    getUniversalTimeStr(timestamp, sizeof(timestamp));

    char line[512];
    sprintf_s(line, sizeof(line), "%s,%s,%s,%d,%s,%s,%d,%d", timestamp, tcpInfo.remoteHostName, tcpInfo.localHostName, tcpInfo.Protocol, tcpInfo.remoteSrvPort, tcpInfo.localSrvPort, tcpInfo.AddressFamily, tcpInfo.SocketType);
    printf("WSARecv:\t%s,%s,%s,%d,%s,%s,%d,%d\n", timestamp, tcpInfo.remoteHostName, tcpInfo.localHostName, tcpInfo.Protocol, tcpInfo.remoteSrvPort, tcpInfo.localSrvPort, tcpInfo.AddressFamily, tcpInfo.SocketType);
    logLine(line);
    
    int retVal = True_WSARecv( s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine );
    //printf("Exit code: %d\n", retVal);
    return retVal;
}

/*
* WSASocketW()
*/
SOCKET WSAAPI Mine_WSASocketW(
  int                 af,
  int                 type,
  int                 protocol,
  LPWSAPROTOCOL_INFOW lpProtocolInfo,
  GROUP               g,
  DWORD               dwFlags
) {
    if (!isThreadInfected) {
        return True_WSASocketW( af, type, protocol, lpProtocolInfo, g, dwFlags );
    }

    //printf("%d %d WSASocketW called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    SOCKET s = True_WSASocketW( af, type, protocol, lpProtocolInfo, g, dwFlags );
    return s;
}

/*
 * WSAStringToAddressW() https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsastringtoaddressw
 */
INT WSAAPI Mine_WSAStringToAddressW(
    LPWSTR              AddressString,
    INT                 AddressFamily,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPSOCKADDR          lpAddress,
    LPINT               lpAddressLength
) {
    if (!isThreadInfected) {
        return True_WSAStringToAddressW(AddressString, AddressFamily, lpProtocolInfo, lpAddress, lpAddressLength);
    }
    printf("%d %d WSAStringToAddress called!\n", GetCurrentProcessId(), GetCurrentThreadId());

    INT res = True_WSAStringToAddressW(AddressString, AddressFamily, lpProtocolInfo, lpAddress, lpAddressLength );
    return res;
}

/*
* bind() hooks
*/
int WINAPI Mine_bind(
    SOCKET         s,
    const sockaddr* addr,
    int            namelen
) {
    if (!isThreadInfected) {
        return True_bind(s, addr, namelen);
    }
    //printf("%d %d bind called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    //printf("%d B: namelen\n", namelen);
    int res = True_bind(s, addr, namelen);
    return res;
}

/*
* socket() hooks
*/
SOCKET WSAAPI Mine_socket(
    int af,
    int type,
    int protocol
) {
    if (!isThreadInfected) {
        return True_socket(af, type, protocol);
    }
    //printf("%d %d socket called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    SOCKET s = True_socket(af, type, protocol);
    return s;
}


INT WSAAPI Mine_getaddrinfo(
    PCSTR           pNodeName,
    PCSTR           pServiceName,
    const ADDRINFOA *pHints,
    PADDRINFOA      *ppResult
) {
    printf("%d %d getaddrinfo() called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    INT res = True_getaddrinfo( pNodeName, pServiceName, pHints, ppResult );
    return res;
}

int WSAAPI Mine_send(
    SOCKET     s,
    const char* buf,
    int        len,
    int        flags
) {
    if (!isThreadInfected) {
        return True_send( s, buf, len, flags );
    }

    //printf("%d %d send() called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    SocketInfo tcpInfo;
    GetSocketInfo(s, &tcpInfo);

    char timestamp[32];
    getUniversalTimeStr(timestamp, sizeof(timestamp));

    char line[512];
    sprintf_s(line, sizeof(line), "%s,%s,%s,%d,%s,%s,%d,%d", timestamp, tcpInfo.localHostName, tcpInfo.remoteHostName, tcpInfo.Protocol, tcpInfo.localSrvPort, tcpInfo.remoteSrvPort, tcpInfo.AddressFamily, tcpInfo.SocketType);
    printf("send:\t\t%s,%s,%s,%d,%s,%s,%d,%d\n", timestamp, tcpInfo.localHostName, tcpInfo.remoteHostName, tcpInfo.Protocol, tcpInfo.localSrvPort, tcpInfo.remoteSrvPort, tcpInfo.AddressFamily, tcpInfo.SocketType);
    logLine(line);

    //printf("timestamp,%s,%s,%s,%s,%d,%d,%d\n", tcpInfo.localHostName, tcpInfo.localSrvPort, tcpInfo.remoteHostName, tcpInfo.remoteSrvPort, tcpInfo.Protocol, tcpInfo.AddressFamily, tcpInfo.SocketType);

    int res = True_send( s, buf, len, flags );
    return res;
}


int Mine_recv(
  SOCKET s,
  char   *buf,
  int    len,
  int    flags
) {
    if (!isThreadInfected) {
        return True_recv(s, buf, len, flags);
    }

    //printf("%d %d recv() called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    SocketInfo tcpInfo;
    GetSocketInfo(s, &tcpInfo);

    char timestamp[32];
    getUniversalTimeStr(timestamp, sizeof(timestamp));

    char line[512];
    sprintf_s(line, sizeof(line), "%s,%s,%s,%d,%s,%s,%d,%d", timestamp, tcpInfo.remoteHostName, tcpInfo.localHostName, tcpInfo.Protocol, tcpInfo.remoteSrvPort, tcpInfo.localSrvPort, tcpInfo.AddressFamily, tcpInfo.SocketType);
    printf("recv:\t\t%s,%s,%s,%d,%s,%s,%d,%d\n", timestamp, tcpInfo.remoteHostName, tcpInfo.localHostName, tcpInfo.Protocol, tcpInfo.remoteSrvPort, tcpInfo.localSrvPort, tcpInfo.AddressFamily, tcpInfo.SocketType);
    logLine(line);

    //printf("timestamp,%s,%s,%s,%s,%d,%d,%d\n", tcpInfo.remoteHostName, tcpInfo.remoteSrvPort, tcpInfo.localHostName, tcpInfo.localSrvPort, tcpInfo.Protocol, tcpInfo.AddressFamily, tcpInfo.SocketType);

    int res = True_recv(s, buf, len, flags);
    return res;
}

DWORD Mine_Icmp6SendEcho2(
IN            HANDLE                 IcmpHandle,
IN OPTIONAL   HANDLE                 Event,
IN OPTIONAL   FARPROC                ApcRoutine,
IN OPTIONAL   PVOID                  ApcContext,
IN            sockaddr_in6*          SourceAddress,
IN            sockaddr_in6*          DestinationAddress,
IN            LPVOID                 RequestData,
IN            WORD                   RequestSize,
IN OPTIONAL   PIP_OPTION_INFORMATION RequestOptions,
OUT           LPVOID                 ReplyBuffer,
IN            DWORD                  ReplySize,
IN            DWORD                  Timeout
) {
    if (!isThreadInfected) {
        return True_Icmp6SendEcho2(IcmpHandle, Event, ApcRoutine, ApcContext, SourceAddress, DestinationAddress, RequestData, RequestSize, RequestOptions, ReplyBuffer, ReplySize, Timeout);
    }
    //printf("%d %d Icmp6SendEcho2() called!\n", GetCurrentProcessId(), GetCurrentThreadId());

    char srcIpString[INET6_ADDRSTRLEN];
    char dstIpString[INET6_ADDRSTRLEN];
    inet_ntop(AF_INET6, &(SourceAddress->sin6_addr), srcIpString, INET6_ADDRSTRLEN);
    inet_ntop(AF_INET6, &(DestinationAddress->sin6_addr), dstIpString, INET6_ADDRSTRLEN);

    char timestamp[32];
    getUniversalTimeStr(timestamp, sizeof(timestamp));

    char line[512];
    printf("Echo6 Request:\t%s,%s,%s,1\n", timestamp, srcIpString, dstIpString);
    sprintf_s(line, sizeof(line), "%s,%s,%s,1", timestamp, srcIpString, dstIpString);
    logLine(line);

    DWORD dwRetValue = True_Icmp6SendEcho2(IcmpHandle, Event, ApcRoutine, ApcContext, SourceAddress, DestinationAddress, RequestData, RequestSize, RequestOptions, ReplyBuffer, ReplySize, Timeout);

    if (dwRetValue != 0) {
        PICMPV6_ECHO_REPLY pEchoReply = (PICMPV6_ECHO_REPLY) ReplyBuffer;
        if (pEchoReply->Status == IP_SUCCESS) { // Se ho ricevuto risposta da chi ho pingato
            char replyIpString[INET6_ADDRSTRLEN];
            inet_ntop(AF_INET6, &(pEchoReply->Address.sin6_addr), replyIpString, INET6_ADDRSTRLEN);
            // Nella risposta lascio il vecchio timestamp perche' non voglio loggare un timestamp successivo alla ricezione effettiva della risposta
            printf("Echo6 Response:\t%s,%s,%s,1\n", timestamp, replyIpString ,srcIpString);
            sprintf_s(line, sizeof(line), "%s,%s,%s,1", timestamp, replyIpString ,srcIpString);
            logLine(line);
        }
    }
    return dwRetValue;
}

/*
 * IcmpSendEcho2Ex 
 * E' usata per pacchetti IPv4
 * Se ricevo risposta il pacchetto di richiesta ICMP echo e la sua reply appaiono entrambi in wireshark
 * Se invece non ricevo risposta, del tipo Host non ranngiugibilie, su Wireshark non appare neanche il pacchetto di richiesta
 * Io nel dubbio, lo loggo comunque, se poi non lo trovo nella cattura totale, lo scarto
 * Meglio loggare il pacchetto e poi non trovarlo nella cattura di rete piuttosto che l'inverso
 */
DWORD Mine_IcmpSendEcho2Ex(
    HANDLE                 IcmpHandle,
    HANDLE                 Event,
    FARPROC                ApcRoutine,
    PVOID                  ApcContext,
    IPAddr                 SourceAddress,
    IPAddr                 DestinationAddress,
    LPVOID                 RequestData,
    WORD                   RequestSize,
    PIP_OPTION_INFORMATION RequestOptions,
    LPVOID                 ReplyBuffer,
    DWORD                  ReplySize,
    DWORD                  Timeout
) {
    if (!isThreadInfected) {
        return True_IcmpSendEcho2Ex(IcmpHandle, Event, ApcRoutine, ApcContext, SourceAddress, DestinationAddress, RequestData, RequestSize, RequestOptions, ReplyBuffer, ReplySize, Timeout);
    }

    //printf("%d %d IcmpSendEcho2Ex() called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    char srcIpString[INET_ADDRSTRLEN];
    char dstIpString[INET_ADDRSTRLEN];

    // L'indirizzo sorgente e' di solito 0.0.0.0 e non un interfaccia specifica. Da considerare in post-processing
    // a meno che non venga specificata l'interfaccia sorgente es: ping -S <src_ip> <dst_ip>
    inet_ntop(AF_INET, &SourceAddress, srcIpString, INET_ADDRSTRLEN);
    inet_ntop(AF_INET, &DestinationAddress, dstIpString, INET_ADDRSTRLEN);

    char timestamp[32];
    getUniversalTimeStr(timestamp, sizeof(timestamp));

    char line[256];
    printf("Echo Request:\t%s,%s,%s,1\n", timestamp, srcIpString, dstIpString);
    sprintf_s(line, sizeof(line), "%s,%s,%s,1", timestamp, srcIpString, dstIpString);
    logLine(line);
    
    DWORD dwRetValue = True_IcmpSendEcho2Ex(IcmpHandle, Event, ApcRoutine, ApcContext, SourceAddress, DestinationAddress, RequestData, RequestSize, RequestOptions, ReplyBuffer, ReplySize, Timeout);

    if (dwRetValue != 0) { // Se ho ricevuto risposta
        PICMP_ECHO_REPLY pEchoReply = (PICMP_ECHO_REPLY) ReplyBuffer;

        if (pEchoReply->Status == IP_SUCCESS) {
            //ReplyAddr non e' strattamente necessario visto che potrei usare dstIpString, ma per ora lascio il codice
            char replyIpString[INET_ADDRSTRLEN];
            struct in_addr ReplyAddr;
            ReplyAddr.S_un.S_addr = pEchoReply->Address;
            inet_ntop(AF_INET, &ReplyAddr, replyIpString, INET_ADDRSTRLEN);
            // Nella risposta lascio il vecchio timestamp perche' non voglio loggare un timestamp successivo alla ricezione effettiva della risposta
            printf("Echo Response:\t%s,%s,%s,1\n", timestamp, replyIpString ,srcIpString);
            sprintf_s(line, sizeof(line), "%s,%s,%s,1", timestamp, replyIpString ,srcIpString);
            logLine(line);
        }
    }
    return dwRetValue;
}

/*
 * Da API monitor non sembro vedere la chiamata di altre api oltre a GetAddrInfoW quando con powershell eseguo `curl google.com`
 * Nel parametro ppResult sono contenute le informazioni della risposta DNS ma non le informazioni sulla connessione (es: socket)
 * GetAddrInfoW() e getaddrinfo() chiedono l'IP associato al dominio direttamente al sistema operativo
 * L'OS o effettua una richiesta di rete al DNS o restituisce quello che ha in cache
 * nslookup invece effettua esplicitamente la richiesta DNS ecco perche' riesco a vedere il processo che fa esplicitamente la richiesta
 *
 * Con GetAddrInfoW() e getaddrinfo() non vedro' il mio processo fare esplicitamente la richiesta
 * Quello che posso fare e' salvarmi il timestamp del momento in cui viene effettuata la chiamata e il dominio cercato dal processo
 * Poi, in post-processing, cerco nella cattura di rete un pacchetto DNS che ha richiesto quel particolare dominio
 * in un instante poco successivo al timestamp che mi sono salvato
 *
 * Dopo aver codificato e testato il tutto, penso lo stesso discorso si applichi a getaddrinfo()
 */
INT WSAAPI Mine_GetAddrInfoW(
IN OPTIONAL PCWSTR              pNodeName,
IN OPTIONAL PCWSTR              pServiceName,
IN OPTIONAL const ADDRINFOW*    pHints,
OUT         PADDRINFOW*         ppResult
){
    if (!isThreadInfected) {
        return True_GetAddrInfoW(pNodeName, pServiceName, pHints, ppResult);
    }
    //printf("%d %d GetAddrInfoW() called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    //wprintf(L"Domain: %s\n", pNodeName);

    char timestamp[32];
    getUniversalTimeStr(timestamp, sizeof(timestamp));

    char line[256];
    printf("GetAddrInfoW:\t%s,dns,%ws\n", timestamp, pNodeName);
    sprintf_s(line, sizeof(line), "%s,dns,%ws", timestamp, pNodeName);
    logLine(line);

    INT res = True_GetAddrInfoW(pNodeName, pServiceName, pHints, ppResult);

    if (res != 0) { //Error in the request
        return res;
    }

    /*
    ADDRINFOW* ptr;
    LPSOCKADDR sockaddr_ip;
    INT iRetval;
    wchar_t ipstringbuffer[46];
    DWORD ipbufferlength = 46;
    int i = 1;

    for (ptr = *ppResult; ptr != NULL; ptr = ptr->ai_next) {
        wprintf(L"GetAddrInfoW response %d\n", i++);
        wprintf(L"\tFlags: 0x%x\n", ptr->ai_flags);
        wprintf(L"\tFamily: ");
        switch (ptr->ai_family) {
            case AF_UNSPEC:
                wprintf(L"Unspecified\n");
                break;
            case AF_INET:
                wprintf(L"AF_INET (IPv4)\n");
                sockaddr_ip = (LPSOCKADDR) ptr->ai_addr;
                // The buffer length is changed by each call to WSAAddresstoString
                // So we need to set it for each iteration through the loop for safety
                ipbufferlength = 46;
                iRetval = WSAAddressToString(sockaddr_ip, (DWORD) ptr->ai_addrlen, NULL, 
                    ipstringbuffer, &ipbufferlength );
                if (iRetval)
                    wprintf(L"WSAAddressToString failed with %u\n", WSAGetLastError() );
                else    
                    wprintf(L"\tIPv4 address %ws\n", ipstringbuffer);
                break;
            case AF_INET6:
                wprintf(L"AF_INET6 (IPv6)\n");
                // the InetNtop function is available on Windows Vista and later
                // sockaddr_ipv6 = (struct sockaddr_in6 *) ptr->ai_addr;
                // printf("\tIPv6 address %s\n",
                //    InetNtop(AF_INET6, &sockaddr_ipv6->sin6_addr, ipstringbuffer, 46) );
                
                // We use WSAAddressToString since it is supported on Windows XP and later
                sockaddr_ip = (LPSOCKADDR) ptr->ai_addr;
                // The buffer length is changed by each call to WSAAddresstoString
                // So we need to set it for each iteration through the loop for safety
                ipbufferlength = 46;
                iRetval = WSAAddressToString(sockaddr_ip, (DWORD) ptr->ai_addrlen, NULL, 
                    ipstringbuffer, &ipbufferlength );
                if (iRetval)
                    wprintf(L"WSAAddressToString failed with %u\n", WSAGetLastError() );
                else    
                    wprintf(L"\tIPv6 address %ws\n", ipstringbuffer);
                break;
            default:
                wprintf(L"Other %ld\n", ptr->ai_family);
                break;
        }
        wprintf(L"\tSocket type: ");
        switch (ptr->ai_socktype) {
            case 0:
                wprintf(L"Unspecified\n");
                break;
            case SOCK_STREAM:
                wprintf(L"SOCK_STREAM (stream)\n");
                break;
            case SOCK_DGRAM:
                wprintf(L"SOCK_DGRAM (datagram) \n");
                break;
            case SOCK_RAW:
                wprintf(L"SOCK_RAW (raw) \n");
                break;
            case SOCK_RDM:
                wprintf(L"SOCK_RDM (reliable message datagram)\n");
                break;
            case SOCK_SEQPACKET:
                wprintf(L"SOCK_SEQPACKET (pseudo-stream packet)\n");
                break;
            default:
                wprintf(L"Other %ld\n", ptr->ai_socktype);
                break;
        }
        wprintf(L"\tProtocol: ");
        switch (ptr->ai_protocol) {
            case 0:
                wprintf(L"Unspecified\n");
                break;
            case IPPROTO_TCP:
                wprintf(L"IPPROTO_TCP (TCP)\n");
                break;
            case IPPROTO_UDP:
                wprintf(L"IPPROTO_UDP (UDP) \n");
                break;
            default:
                wprintf(L"Other %ld\n", ptr->ai_protocol);
                break;
        }
        wprintf(L"\tLength of this sockaddr: %d\n", ptr->ai_addrlen);
        wprintf(L"\tCanonical name: %s\n", ptr->ai_canonname);
    }
    */

    return res;
} 