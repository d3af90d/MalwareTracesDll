#pragma once

//#ifndef WIN32_LEAN_AND_MEAN
//#define WIN32_LEAN_AND_MEAN
//#endif

#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>

#include <detours.h>

#include "TypeDefinitions.h"
#include "Utils.h"

//#include <winsock2.h>
//#include <ws2tcpip.h>
//// Need to link with Ws2_32.lib
//#pragma comment(lib, "ws2_32.lib")

//static LPCSTR Mine_Dll = "C:\\Users\\user\\source\\repos\\MalwareTracesDll\\x64\\Debug\\MalwareTracesDll.dll";

// Da aggiustare
BOOL loadLibraryOnRemoteProcess(HANDLE hTargetProcess, const char* dll) {
//    HANDLE hTargetProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD, FALSE, targetPid);
//    if (!hTargetProcess) {
//        printf("Error opening process\n");
//        return FALSE;
//    }
    LPVOID remoteDllString = VirtualAllocEx(hTargetProcess, NULL, strlen(dll) + 1, MEM_COMMIT, PAGE_READWRITE);
    if (!remoteDllString) {
        printf("Error allocating memory for dll\n");
        return FALSE;
    }
    printf("Allocated memory for testDll\n");
    WriteProcessMemory(hTargetProcess, remoteDllString, dll, strlen(dll) + 1, NULL);

    HMODULE hKernel32 = GetModuleHandle(L"kernel32.dll");
    LPVOID loadLibraryAddr = GetProcAddress(hKernel32, "LoadLibraryA");
    if (!loadLibraryAddr) {
        printf("Failed to get the address of LoadLibraryA.\n");
        return FALSE;
    }
    printf("Loaded address of LoadLibraryA.\n");

    PTHREAD_START_ROUTINE pThreadRtn = (PTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryA");

    //HANDLE hRemoteThread = CreateRemoteThread(hTargetProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddr, remoteDllString, 0, NULL);
    HANDLE hRemoteThread = True_CreateRemoteThread(hTargetProcess, NULL, 0, pThreadRtn, remoteDllString, 0, NULL);
    if (!hRemoteThread) {
        printf("Failed to create a remote thread for loading wininet.dll.\n");
        return FALSE;
    }
    printf("Created remote thread for loading the testDll...\n");

    WaitForSingleObject(hRemoteThread, INFINITE);

    return TRUE;
}

/*
 * ================== PROCESS AND THREAD CREATION HOOKS
 */

/*
* CreateProcess() Hooks
* Invece di chiamare la CreateProcess() originale, chiamo DetourCreateProcessWithDllEx
* in modo che la mia Dll sia iniettata nel nuovo processo
*/
BOOL WINAPI Mine_CreateProcess(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
) {
    printf("%d %d CreateProcess called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    BOOL result = True_DetourCreateProcessWithDllEx( lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation, Mine_Dll, True_CreateProcess );
    //printf("pid: %d\n", lpProcessInformation->dwProcessId);
    return result;
}

/*
* CreateRemoteThread() Hooks
* Devo iniettare questa DLL nel processo su cui e' stato creato il thread remoto e
* aggiungere pid e threadid tra quelli infetti
*/
HANDLE WINAPI Mine_CreateRemoteThread(
  HANDLE                 hProcess,
  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
  SIZE_T                 dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID                 lpParameter,
  DWORD                  dwCreationFlags,
  LPDWORD                lpThreadId
) {
    printf("%d %d CreateRemoteThread called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    // TODO: Salvare informazioni sul PID su cui si e' iniettato il malware e 
    //loadLibraryOnRemoteProcess(hProcess, Mine_Dll);
    HANDLE hThread = True_CreateRemoteThread( hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId );
    return hThread;
}

/*
* CreateThread() Hooks
* Il thread viene creato nel processo corrente quindi devo solo aggiungere il threadID tra quelli infetti
*/
HANDLE WINAPI Mine_CreateThread(
    LPSECURITY_ATTRIBUTES   lpThreadAttributes,
    SIZE_T                  dwStackSize,
    LPTHREAD_START_ROUTINE  lpStartAddress,
    __drv_aliasesMem LPVOID lpParameter,
    DWORD                   dwCreationFlags,
    LPDWORD                 lpThreadId
) {
    //Controllare che lpThreadId non sia NULL, se e' null creo una variabile per poter leggere il threadId del thread creato
    printf("%d %d CreateThread called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    HANDLE hThread = True_CreateThread( lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId );
    return hThread;
}

/*
 * ==================== NETWORK RELATED HOOKS
 */

/*
* WSASend() hooks
*/
int WSAAPI Mine_WSASend(
    SOCKET                             s,
    LPWSABUF                           lpBuffers,
    DWORD                              dwBufferCount,
    LPDWORD                            lpNumberOfBytesSent,
    DWORD                              dwFlags,
    LPWSAOVERLAPPED                    lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
) {
    printf("%d %d WSASend called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    int res = True_WSASend( s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine );
    return res;
}

/*
* bind() hooks
*/
int WINAPI Mine_bind(
    SOCKET         s,
    const sockaddr* addr,
    int            namelen
) {
    printf("%d %d bind called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    int res = True_bind(s, addr, namelen);
    return res;
}

/*
* WSASocketW()
* Spiegare a che serve e quando viene chiamata
*/
SOCKET WSAAPI Mine_WSASocketW(
  int                 af,
  int                 type,
  int                 protocol,
  LPWSAPROTOCOL_INFOW lpProtocolInfo,
  GROUP               g,
  DWORD               dwFlags
) {
    printf("%d %d WSASocketW called!\n", GetCurrentProcessId(), GetCurrentThreadId());
    SOCKET s = True_WSASocketW( af, type, protocol, lpProtocolInfo, g, dwFlags );
    return s;
}
