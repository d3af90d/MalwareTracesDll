#pragma once

#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>

#include <time.h>

#include <winsock2.h>
#include <ws2tcpip.h>

#include <fstream>
#include <sstream>

#pragma comment(lib, "ws2_32.lib")

#include "TypeDefinitions.h"

static LPCSTR Mine_Dll = "C:\\Users\\user\\source\\repos\\MalwareTracesDll\\x64\\Debug\\MalwareTracesDll.dll";
static const char* infectedFile = "C:\\malwareTraces\\malwareTracesDll\\infected.txt";
static const char* logFile = "C:\\malwareTraces\\malwareTracesDll\\log.txt";

__declspec(thread) BOOL isThreadInfected = FALSE;

struct SocketInfo {
    char localHostName[NI_MAXHOST];
    char localSrvPort[NI_MAXSERV];
    char remoteHostName[NI_MAXHOST];
    char remoteSrvPort[NI_MAXSERV];
    int Protocol;
    int AddressFamily;
    int SocketType;
};

void logInfo(char* line) {
    DWORD processId = GetCurrentProcessId();
    DWORD threadId = GetCurrentThreadId();

    std::ostringstream filenameStream;
    filenameStream << "C:\\malwareTraces\\malwareTracesDll\\infos\\" << processId << "_" << threadId << ".txt";
    std::string filename = filenameStream.str();
    std::ofstream outFile(filename, std::ios::app);  // Open the file for appending

    if (outFile.is_open()) {
        outFile << line << std::endl;  // Append the line
        outFile.close();
        //std::cout << "Appended to " << filename << ": " << line << std::endl;
    } else {
        //std::cerr << "Error: Couldn't open file for appending." << std::endl;
    }
}


/*
 * 
 */
void getUniversalTimeStr(char* buffer, int bufferSize) {
    SYSTEMTIME st;
    GetSystemTime(&st);

    snprintf(buffer, bufferSize, "%04d-%02d-%02dT%02d:%02d:%02d.%03d0000Z",
             st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
}


BOOL loadLibraryOnRemoteProcess(DWORD targetPid, const char* dll)
{
    HANDLE hTargetProcess =  OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD, FALSE, targetPid);
    LPVOID remoteDllString = VirtualAllocEx(hTargetProcess, NULL, strlen(dll) + 1, MEM_COMMIT, PAGE_READWRITE);
    WriteProcessMemory(hTargetProcess, remoteDllString, dll, strlen(dll) + 1, NULL);
    PTHREAD_START_ROUTINE pThreadRtn = (PTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryA");
    printf("Sto per iniettare MalwareTracesDll in un processo remoto!\n");
    HANDLE hRemoteThread = True_CreateRemoteThread(hTargetProcess, NULL, 0, pThreadRtn, remoteDllString, 0, NULL);
    WaitForSingleObject(hRemoteThread, INFINITE);
    printf("Ho iniettato MalwareTracesDll in un processo remoto!\n");
    return TRUE;
}

// Temp function for testing
void writeToFile(DWORD pid, DWORD threadId) {
    std::ofstream file(infectedFile, std::ios::app);
    if (file.is_open()) {
        file << pid << " " << threadId << std::endl;
        file.close();
    }
}

void AppendLineToFile(const std::string& filePath, const std::string& line) {
    std::ofstream file(filePath, std::ios::app); // Open the file in append mode

    if (file.is_open()) {
        file << line << std::endl; // Append the formatted line and a newline
        file.close(); // Close the file
    } else {
        std::cerr << "Error: Unable to open file for appending." << std::endl;
    }
}

void LogToFile(char* line) {
    std::ofstream file(logFile, std::ios::app);
    if (file.is_open()) {
        file << line << std::endl;
        file.close();
    }
}

BOOL IsCallerInfected(long processId, long ThreadId) {
    std::ifstream inputFile(infectedFile);

    std::string targetLine = std::to_string(processId) + " " + std::to_string(ThreadId);
    std::string lineRead;

    while (std::getline(inputFile, lineRead)) {
        if (lineRead == targetLine) {
			inputFile.close();
            return TRUE;
        }
    }

    inputFile.close();
    return FALSE;
}

// getpeername() https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername
// getnameinfo() https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getnameinfo
// getsockname() https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname
// getsockopt()  https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockopt
void GetSocketInfo(SOCKET s, SocketInfo* info) {

    // Ottengo informazioni sul lato remoto (IP, Port) della socket
    struct sockaddr_storage peerSockInfo;
    int peerSockInfoLen = sizeof(peerSockInfo);
    if (getpeername(s, (LPSOCKADDR)&peerSockInfo, &peerSockInfoLen) != 0) {
        printf("getpeername() failed - Error %d\n", WSAGetLastError());
        return;
    }
    if (getnameinfo((LPSOCKADDR)&peerSockInfo, peerSockInfoLen, info->remoteHostName, sizeof(info->remoteHostName), info->remoteSrvPort, sizeof(info->remoteSrvPort), NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
        printf("getinfoname() failed - Error %d\n", WSAGetLastError());
        return;
    }
    //printf("REMOTE: Connected to %s, port %s\n", info->remoteHostName, info->remoteSrvPort);

    // Ottengo informazioni sul lato locale (IP, Port) della socket
    struct sockaddr_storage localSockInfo;
    int localSockInfoLen = sizeof(localSockInfo);
    if (getsockname(s, (LPSOCKADDR)&localSockInfo, &localSockInfoLen) == SOCKET_ERROR)
    {
        fprintf(stderr, "Client: getsockname() failed with error %d\n", WSAGetLastError());
        return;
    }
    if (getnameinfo((LPSOCKADDR)&localSockInfo, localSockInfoLen, info->localHostName, sizeof(info->localHostName), info->localSrvPort, sizeof(info->localSrvPort), NI_NUMERICHOST) != 0) {
        printf("getinfoname() failed - Error %d\n", WSAGetLastError());
        return;
    }
    //printf("LOCAL: Address %s, Port %s\n", info->localHostName, info->localSrvPort);

    // Ottengo informazioni sul tipo di socket (IPv4, IPv6,...)
    WSAPROTOCOL_INFOW protocolInfo;
    int protocolInfoLen = sizeof(protocolInfo);
    if (getsockopt(s, SOL_SOCKET, SO_PROTOCOL_INFO, (char*)&protocolInfo, &protocolInfoLen) != 0) {
        printf("ERROR: Unable to retrieve protocol and protocol family - Error %d\n", WSAGetLastError());
        return;
    }
    info->Protocol = protocolInfo.iProtocol;
    info->AddressFamily = protocolInfo.iAddressFamily;
    info->SocketType = protocolInfo.iSocketType;
    //printf("Protocol %d, AddressFamily %d, SocketType %d\n", info->Protocol, info->AddressFamily, info->SocketType);
}
