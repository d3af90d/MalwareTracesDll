#pragma once

#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>

static LPCSTR Mine_Dll = "C:\\Users\\user\\source\\repos\\MalwareTracesDll\\x64\\Debug\\MalwareTracesDll.dll";
static const char* infectedFile = "C:\\malwareTraces\\malwareTracesDll\\infected.txt";
static const char* logFile = "C:\\malwareTraces\\malwareTracesDll\\log.txt";


struct SocketInfo {
    char remoteHostName[NI_MAXHOST];
    char localHostName[NI_MAXHOST];

    char remoteSrvPort[NI_MAXSERV];
    char localSrvPort[NI_MAXSERV];

//    u_short remotePort;
//    u_short localPort;

    int Protocol;
    int AddressFamily;
    int SocketType;
};

/*
 * La funzioni in questo file sono tutte da aggiustare
 */

BOOL loadLibraryOnRemoteProcess(DWORD targetPid, const char* dll)
{
    HANDLE hTargetProcess =  OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD, FALSE, targetPid);
    LPVOID remoteDllString = VirtualAllocEx(hTargetProcess, NULL, strlen(dll) + 1, MEM_COMMIT, PAGE_READWRITE);
    WriteProcessMemory(hTargetProcess, remoteDllString, dll, strlen(dll) + 1, NULL);
    PTHREAD_START_ROUTINE pThreadRtn = (PTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryA");
    HANDLE hRemoteThread = True_CreateRemoteThread(hTargetProcess, NULL, 0, pThreadRtn, remoteDllString, 0, NULL);
    WaitForSingleObject(hRemoteThread, INFINITE);
    return TRUE;
}

void writeToFile(DWORD pid, DWORD threadId) {
    std::ofstream file(infectedFile, std::ios::app);
    if (file.is_open()) {
        file << pid << " " << threadId << std::endl;
        file.close();
    }
}

void LogToFile(char* line) {
    std::ofstream file(logFile, std::ios::app);
    if (file.is_open()) {
        file << line << std::endl;
        file.close();
    }
}

BOOL IsCallerInfected(DWORD processId, DWORD ThreadId) {
    std::ifstream inputFile(infectedFile);

    std::string targetLine = std::to_string(processId) + " " + std::to_string(ThreadId);
    std::string lineRead;

    // Devo aprire il file? non l'ho eseguita mai ancora
    while (std::getline(inputFile, lineRead)) {
        if (lineRead == targetLine) {
            return TRUE;
        }
    }

    inputFile.close();
    return FALSE;
}

// getpeername() https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername
// getnameinfo() https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getnameinfo
// getsockname()
// getsockopt()
void GetSocketInfo(SOCKET s, SocketInfo* info) {
    struct sockaddr_storage peerSockInfo;
    int peerSockInfoLen = sizeof(peerSockInfo);

    if (getpeername(s, (LPSOCKADDR)&peerSockInfo, &peerSockInfoLen) != 0) {
        printf("getpeername() failed - Error %d\n", WSAGetLastError());
        return;
    }

    if (getnameinfo((LPSOCKADDR)&peerSockInfo, peerSockInfoLen, info->remoteHostName, sizeof(info->remoteHostName), info->remoteSrvPort, sizeof(info->remoteSrvPort), NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
        printf("getinfoname() failed - Error %d\n", WSAGetLastError());
        return;
    }
	//printf("REMOTE: Connected to %s, port %s\n", info->remoteHostName, info->remoteSrvPort);

//    char line[1024];
//    snprintf(line, sizeof(line), "Client: Connected to %s, port %d, protocol , protocol family", info->remoteHostName, info->remotePort);
//    LogToFile(line);

    struct sockaddr_storage localSockInfo;
    int localSockInfoLen = sizeof(localSockInfo);

    if (getsockname(s, (LPSOCKADDR)&localSockInfo, &localSockInfoLen) == SOCKET_ERROR)
    {
        fprintf(stderr, "Client: getsockname() failed with error %d\n", WSAGetLastError());
        return;
    }

    if (getnameinfo((LPSOCKADDR)&localSockInfo, localSockInfoLen, info->localHostName, sizeof(info->localHostName), info->localSrvPort, sizeof(info->localSrvPort), NI_NUMERICHOST) != 0) {
        printf("getinfoname() failed - Error %d\n", WSAGetLastError());
        return;
    }
	//printf("LOCAL: Address %s, Port %s\n", info->localHostName, info->localSrvPort);

    WSAPROTOCOL_INFOW protocolInfo;
	int protocolInfoLen = sizeof(protocolInfo);

	if (getsockopt(s, SOL_SOCKET, SO_PROTOCOL_INFO, (char*)&protocolInfo, &protocolInfoLen) != 0) {
		printf("ERROR: Unable to retrieve protocol and protocol family - Error %d\n", WSAGetLastError());
        return;
	}

	info->Protocol = protocolInfo.iProtocol;
	info->AddressFamily = protocolInfo.iAddressFamily;
	info->SocketType = protocolInfo.iSocketType;
}
