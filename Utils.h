#pragma once

#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <iostream>
#include <fstream>
#include <sstream>

#include "TypeDefinitions.h"

static const LPCSTR Mine_Dll = "C:\\malwareTraces\\MalwareTracesDll.dll";
static const char* infectedFile = "C:\\malwareTraces\\infected.txt";

__declspec(thread) BOOL isThreadInfected = FALSE;
__declspec(thread) DWORD currentProcessId;
__declspec(thread) DWORD currentThreadId;
__declspec(thread) DWORD parentProcessId;
__declspec(thread) WCHAR processName[MAX_PATH];

struct SocketInfo {
    char localHostName[NI_MAXHOST];
    char localSrvPort[NI_MAXSERV];
    char remoteHostName[NI_MAXHOST];
    char remoteSrvPort[NI_MAXSERV];
    int Protocol;
    int AddressFamily;
    int SocketType;
};

void GetPPIDAndName(DWORD targetProcessId, DWORD* parentProcessId, WCHAR* nameBuf) {
    PROCESSENTRY32 pe32 = { 0 };
    pe32.dwSize = sizeof(PROCESSENTRY32);
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (hSnapshot == INVALID_HANDLE_VALUE) goto quit; 
    if (!Process32First(hSnapshot, &pe32)) goto quit; 

    while (pe32.th32ProcessID != targetProcessId)
        if (!Process32Next(hSnapshot, &pe32)) goto quit;

    *parentProcessId = pe32.th32ParentProcessID;
    wcscpy_s(nameBuf, MAX_PATH, pe32.szExeFile);

    quit:
        CloseHandle(hSnapshot);
        return;
}

void logLineInThreadFile(char* line) {
    std::ostringstream filenameStream;
    filenameStream << "C:\\malwareTraces\\packet_info\\" << currentProcessId << "_" << currentThreadId << ".txt";
    std::string filename = filenameStream.str();
    std::ofstream outFile(filename, std::ios::app);

    if (outFile.is_open()) {
        outFile << line << std::endl;
        outFile.close();
    }
}

void AppendLineToFile(const std::string& filePath, const std::string& line) {
    std::ofstream file(filePath, std::ios::app);
    if (file.is_open()) {
        file << line << std::endl;
        file.close();
    }
}

void getUniversalTimeStr(char* buffer, int bufferSize) {
    SYSTEMTIME st;
    GetSystemTime(&st);

    snprintf(buffer, bufferSize, "%04d-%02d-%02dT%02d:%02d:%02d.%03d0000Z",
             st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
}

BOOL loadLibraryOnRemoteProcess(DWORD targetPid, const char* dll)
{
    HANDLE hTargetProcess =  OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD, FALSE, targetPid);
    LPVOID remoteDllString = VirtualAllocEx(hTargetProcess, NULL, strlen(dll) + 1, MEM_COMMIT, PAGE_READWRITE);
    WriteProcessMemory(hTargetProcess, remoteDllString, dll, strlen(dll) + 1, NULL);
    PTHREAD_START_ROUTINE pThreadRtn = (PTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryA");
    printf("Sto per iniettare MalwareTracesDll in un processo remoto!\n");
    HANDLE hRemoteThread = True_CreateRemoteThread(hTargetProcess, NULL, 0, pThreadRtn, remoteDllString, 0, NULL);
    WaitForSingleObject(hRemoteThread, INFINITE);
    printf("Ho iniettato MalwareTracesDll in un processo remoto!\n");
    return TRUE;
}

BOOL IsCallerInfected(long processId, long ThreadId) {
    std::ifstream inputFile(infectedFile);
    std::string targetLine = std::to_string(processId) + " " + std::to_string(ThreadId);
    std::string lineRead;

    while (std::getline(inputFile, lineRead)) {
        if (lineRead == targetLine) {
            inputFile.close();
            return TRUE;
        }
    }

    inputFile.close();
    return FALSE;
}

// getpeername() https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername
// getnameinfo() https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getnameinfo
// getsockname() https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname
// getsockopt()  https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockopt
void GetSocketInfo(SOCKET s, SocketInfo* info) {

    // Ottengo informazioni sul lato remoto (IP, Port) della socket
    struct sockaddr_storage peerSockInfo;
    int peerSockInfoLen = sizeof(peerSockInfo);
    if (getpeername(s, (LPSOCKADDR)&peerSockInfo, &peerSockInfoLen) != 0) {
        printf("getpeername() failed - Error %d\n", WSAGetLastError());
        return;
    }
    if (getnameinfo((LPSOCKADDR)&peerSockInfo, peerSockInfoLen, info->remoteHostName, sizeof(info->remoteHostName), info->remoteSrvPort, sizeof(info->remoteSrvPort), NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
        printf("getinfoname() failed - Error %d\n", WSAGetLastError());
        return;
    }
    //printf("REMOTE: Connected to %s, port %s\n", info->remoteHostName, info->remoteSrvPort);

    // Ottengo informazioni sul lato locale (IP, Port) della socket
    struct sockaddr_storage localSockInfo;
    int localSockInfoLen = sizeof(localSockInfo);
    if (getsockname(s, (LPSOCKADDR)&localSockInfo, &localSockInfoLen) == SOCKET_ERROR)
    {
        fprintf(stderr, "Client: getsockname() failed with error %d\n", WSAGetLastError());
        return;
    }
    if (getnameinfo((LPSOCKADDR)&localSockInfo, localSockInfoLen, info->localHostName, sizeof(info->localHostName), info->localSrvPort, sizeof(info->localSrvPort), NI_NUMERICHOST) != 0) {
        printf("getinfoname() failed - Error %d\n", WSAGetLastError());
        return;
    }
    //printf("LOCAL: Address %s, Port %s\n", info->localHostName, info->localSrvPort);

    // Ottengo informazioni sul tipo di socket (IPv4, IPv6,...)
    WSAPROTOCOL_INFOW protocolInfo;
    int protocolInfoLen = sizeof(protocolInfo);
    if (getsockopt(s, SOL_SOCKET, SO_PROTOCOL_INFO, (char*)&protocolInfo, &protocolInfoLen) != 0) {
        printf("ERROR: Unable to retrieve protocol and protocol family - Error %d\n", WSAGetLastError());
        return;
    }
    info->Protocol = protocolInfo.iProtocol;
    info->AddressFamily = protocolInfo.iAddressFamily;
    info->SocketType = protocolInfo.iSocketType;
    //printf("Protocol %d, AddressFamily %d, SocketType %d\n", info->Protocol, info->AddressFamily, info->SocketType);
}
