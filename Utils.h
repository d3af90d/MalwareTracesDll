#pragma once

static LPCSTR Mine_Dll = "C:\\Users\\user\\source\\repos\\MalwareTracesDll\\x64\\Debug\\MalwareTracesDll.dll";
static const char* infectedFile = "C:\\malwareTraces\\malwareTracesDll\\infected.txt";

/*
 * La funzioni in questo file sono tutte da aggiustare
 */

BOOL loadLibraryOnRemoteProcess(HANDLE hTargetProcess, const char* dll)
{
    LPVOID remoteDllString = VirtualAllocEx(hTargetProcess, NULL, strlen(dll) + 1, MEM_COMMIT, PAGE_READWRITE);
    if (!remoteDllString) {
        printf("Error allocating memory for dll\n");
        return FALSE;
    }
    WriteProcessMemory(hTargetProcess, remoteDllString, dll, strlen(dll) + 1, NULL);

    PTHREAD_START_ROUTINE pThreadRtn = (PTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryA");
    HANDLE hRemoteThread = True_CreateRemoteThread(hTargetProcess, NULL, 0, pThreadRtn, remoteDllString, 0, NULL);
    WaitForSingleObject(hRemoteThread, INFINITE);
    return TRUE;
}

void writeToFile(DWORD pid, DWORD threadId) {
    std::ofstream file(infectedFile, std::ios::app);
    if (file.is_open()) {
        // Append the numbers to the file
        file << pid << " " << threadId << std::endl;
        file.close();
    }
}

BOOL IsCallerInfected(DWORD processId, DWORD ThreadId) {
    std::ifstream inputFile(infectedFile);

    std::string targetLine = std::to_string(processId) + " " + std::to_string(ThreadId);
    std::string lineRead;

    while (std::getline(inputFile, lineRead)) {
        if (lineRead == targetLine) {
            return TRUE;
        }
    }

    inputFile.close();
    return FALSE;
}
