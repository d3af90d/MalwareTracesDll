// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"

#include <detours.h>
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <string>

#include "Hooks.h"

/*
 * Macro che rendono piu' leggibile il codice e piu' facile attivare/disattivare gli hook di specifiche funzioni
 */
#define ATTACH(x)       DetourAttach(&(PVOID&)True_##x,Mine_##x)
#define DETACH(x)       DetourDetach(&(PVOID&)True_##x,Mine_##x)

/* 
 * Export the function with ordinal number 1
 * It is needed to be able to inject the DLL with the fx DetoursCreateProcessWithDllEx
 * I think is needed so that the code of our Dll is the first to get executed
 * I guess the Dll becomes the entry point of our binary
 * DOCS of DetourCreateProcessWithDllEx
 * Note: The new process will fail to start if the target DLL does not contain a exported function with ordinal #1.
 */ 
extern "C" __declspec(dllexport) void __stdcall EntryPoint() { }

BOOL APIENTRY DllMain( HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved )
{
    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    DWORD currentProcessId = GetCurrentProcessId();
    DWORD currentThreadId = GetCurrentThreadId();

    // Prima di tutto controllo se il processo/thread chiamante e' infetto
    // Solo in caso sia infetto, esegui il codice di hook
    if (!isThreadInfected) {
        //printf("Controllo se solo il thread chiamante e' infetto\n");
        isThreadInfected = IsCallerInfected(currentProcessId, currentThreadId);
    }

    if (!isThreadInfected) {
        //printf("%d %d Controllo se l'intero processo e' infetto\n", currentProcessId, currentThreadId);
        isThreadInfected = IsCallerInfected(currentProcessId, -1);
    }

    /*
    char line[100];
    sprintf_s(line, sizeof(line), "%d %d\r", currentProcessId, currentThreadId);
    */

    switch(ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:

            /*
            if (isThreadInfected) {
                printf("%d %d | DLL_PROCESS_ATTACH\n", GetCurrentProcessId(), GetCurrentThreadId());
                printf("Sono un processo infetto. PID: %d\n", GetCurrentProcessId());
            }
            */

            DetourRestoreAfterWith();
            DetourTransactionBegin();
            DetourUpdateThread(GetCurrentThread());

            // PROCESS & THREADS
            ATTACH(CreateProcess);
            ATTACH(CreateRemoteThread);
            ATTACH(CreateThread);
            //ATTACH(NtCreateThreadEx);

            // NETWORK
            ATTACH(socket);
            ATTACH(bind);
            ATTACH(send);
            ATTACH(recv);
            ATTACH(WSASend);
            ATTACH(WSARecv);
            ATTACH(WSASocketW);
            ATTACH(WSAStringToAddressW);
            ATTACH(getaddrinfo);
            ATTACH(IcmpSendEcho2Ex);
            ATTACH(Icmp6SendEcho2);
            ATTACH(GetAddrInfoW);
            DetourTransactionCommit();

            break;

        case DLL_THREAD_ATTACH:

            /*
            if (isThreadInfected) {
                printf("%d %d | DLL_THREAD_ATTACH\n", GetCurrentProcessId(), GetCurrentThreadId());
                printf("Sono un thread infetto: %d\n", GetCurrentThreadId());
            }
            */

            break;

        case DLL_THREAD_DETACH:
            /*
            if (isThreadInfected) {
                printf("%d %d | DLL_THREAD_DETACH\n", GetCurrentProcessId(), GetCurrentThreadId());
            }
            */

            break;

        case DLL_PROCESS_DETACH:
            /*
            if (isThreadInfected) {
                printf("%d %d | DLL_PROCESS_DETACH\n", GetCurrentProcessId(), GetCurrentThreadId());
            }
            */
            
            DetourTransactionBegin();
            DetourUpdateThread(GetCurrentThread());

            // PROCESS & THREADS
            DETACH(CreateProcess);
            DETACH(CreateRemoteThread);
            DETACH(CreateThread);
            //DETACH(NtCreateThreadEx);

            // NETWORK
            DETACH(socket);
            DETACH(bind);
            DETACH(send);
            DETACH(recv);
            DETACH(WSASend);
            DETACH(WSARecv);
            DETACH(WSASocketW);
            DETACH(WSAStringToAddressW);
            DETACH(getaddrinfo);
            DETACH(IcmpSendEcho2Ex);
            DETACH(Icmp6SendEcho2);
            DETACH(GetAddrInfoW);
            DetourTransactionCommit();

            break;
    }
    return TRUE;
}

